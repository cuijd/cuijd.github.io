<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>崔先生的Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="崔先生的Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="崔先生的Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="崔先生的Blog">
  
    <link rel="alternate" href="/atom.xml" title="崔先生的Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">崔先生的Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-git的使用经验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/git的使用经验/" class="article-date">
  <time datetime="2018-04-10T03:14:59.726Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/git的使用经验/">git的使用经验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##<br>git命令和误区整理<br>git的安装过程在这里就忽略了<br>git版本查看命令<br>git –version<br>git的整个使用设置<br>1》设置用户名和邮箱（全局和本地（去掉global即可））<br>git config –global user.name “user.name”<br>git config –global user.email “user.email”<br>(此处有操作上的坑，在设定完用户名和email后不可做额外操作<br>如有对代码的各种操作如pull，commit，push等切记用这个账户完成全部操作，而且email必须是在远程库里边设置过并且有权限的)<br>我们继续git的使用设置<br>生成SSH<br>ssh-keygen -t rsa<br>查看SSH<br>cat ~/.ssh/id_rsa.pub<br>拷贝粘贴到github里边的个人信息的SSH公匙里<br>这样就设置完整了</p>
<p>git查看全部配置信息<br>git config –list<br>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:han1202012/TabHost_Test.git（地址）<br>push信息到远程库<br>第一个develop-minor为本地分支<br>后一个为远程仓库的分支<br>git push origin develop-minor:refs/for/develop-minor<br>git丢弃文件<br>git checkout – a.txt<br>git checkout . 丢弃全部<br>git add xxx  后，代码不想提交了<br>git reset HEAD .  或者<br>git reset HEAD a.js<br>如果想要回退到之前某一个版本可以如下操作<br>git reset –hard 5dc29bebe8 这个是回退到指定版本<br>git reset –hard HEAD^这个是会退到之前的版本</p>
<p>这里说一个git的log命令<br>git log会显示最近3次提交的版本记录谁提交的邮箱是哪个都会显示出来<br>不仅如此git还提供了一定的格式占位符来代表一定的意义如下<br>%H    提交对象（commit）的完整哈希字串<br>%h    提交对象的简短哈希字串<br>%T    树对象（tree）的完整哈希字串<br>%t    树对象的简短哈希字串<br>%P    父对象（parent）的完整哈希字串<br>%p    父对象的简短哈希字串<br>%an    作者（author）的名字<br>%ae    作者的电子邮件地址<br>%ad    作者修订日期（可以用 -date= 选项定制格式）<br>%ar    作者修订日期，按多久以前的方式显示<br>%cn    提交者(committer)的名字<br>%ce    提交者的电子邮件地址<br>%cd    提交日期<br>%cr    提交日期，按多久以前的方式显示<br>%s    提交说明<br>命令模本如下<br>$ git log –pretty=format:”%h - %an, %ar : %s”<br>git log还有其他的用法这里就不多说了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/git的使用经验/" data-id="cjh1laqw80000a5bt9w7ibu3g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java四大元注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/java四大元注解/" class="article-date">
  <time datetime="2018-04-10T03:14:59.726Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/java四大元注解/">JAVA的四大元注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>元注解是注解的注解，包括@Retention @Target @Document @Inherited四种</p>
<p>##<br>1:@Retention:定义注解的保留策略<br>@Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在class字节码文件中不包含<br>@Retention(RetentionPolicy.CLASS)     // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，<br>@Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到<br>首 先要明确生命周期长度 SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解；如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，则可选用 SOURCE 注解。<br>枚举的三种策略<br>public enum RetentionPolicy {<br>SOURCE,<br>CLASS,<br>RUNTIME<br>}<br>三种不同策略去注解三个方法<br>@Retention(RetentionPolicy.SOURCE)<br>public @interface SourceLevel {<br>}<br>@Retention(RetentionPolicy.CLASS)<br>public @interface ClassLevel {<br>}<br>@Retention(RetentionPolicy.RUNTIME)<br>public @interface RuntimeLevel {<br>}</p>
<p>public class Test {</p>
<p>@SourceLevel<br>public void sourceLevel(){}<br>@ClassLevel<br>public void classLevel(){};<br>@RuntimeLevel<br>public void runtimeLevel(){};</p>
<p>}</p>
<p>2.@Target：定义注解的作用目标<br>指示注释类型所适用的程序元素的种类。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。 例如，此元注释指示该声明类型是其自身，即元注释类型。它只能用在注释类型声明上<br>源码为：<br>@Documented<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.ANNOTATION_TYPE)<br>public @interface Target {<br>ElementType[] value();<br>}<br>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法<br>@Target(ElementType.PARAMETER) //方法参数<br>@Target(ElementType.CONSTRUCTOR)  //构造函数<br>@Target(ElementType.LOCAL_VARIABLE)//局部变量<br>@Target(ElementType.ANNOTATION_TYPE)//注解<br>@Target(ElementType.PACKAGE) ///包  </p>
<p>3.@Document：说明该注解将被包含在javadoc中</p>
<p>4.@Inherited：说明子类可以继承父类中的该注解</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/java四大元注解/" data-id="cjh1laqwc0001a5bt0zuom123" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java并发编程--Executor框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/java并发编程--Executor框架/" class="article-date">
  <time datetime="2018-04-10T03:14:59.726Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/java并发编程--Executor框架/">JAVA并发编程--Executor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##<br>Eexecutor作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用Runnable来表示任务，Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。<br>1.Exexctor简介<br>Executor的UML图：（常用的几个接口和子类）<br><a href="https://images2015.cnblogs.com/blog/776259/201604/776259-20160426201537486-1323529733.png" target="_blank" rel="noopener">https://images2015.cnblogs.com/blog/776259/201604/776259-20160426201537486-1323529733.png</a><br>Executor：一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command),</p>
<p>ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法</p>
<p>AbstractExecutorService：ExecutorService执行方法的默认实现</p>
<p>ScheduledExecutorService：一个可定时调度任务的接口</p>
<p>ScheduledThreadPoolExecutor：ScheduledExecutorService的实现，一个可定时调度任务的线程池</p>
<p>ThreadPoolExecutor：线程池，可以通过调用Executors以下静态工厂方法来创建线程池并返回一个ExecutorService对象：<br>2.ThreadPoolExecutor构造函数的各个参数说明<br>ThreadPoolExecutor方法签名</p>
<p>public ThreadPoolExecutor(int corePoolSize,<br>                    int maximumPoolSize,<br>                    long keepAliveTime,<br>                    TimeUnit unit,<br>                    BlockingQueue<runnable> workQueue,<br>                    ThreadFactory threadFactory,<br>                    RejectedExecutionHandler handler) //后两个参数为可选参数<br>参数说明：<br>corePoolSize：核心线程数，如果运行的线程少于corePoolSize，则创建新线程来执行新任务，即使线程池中的其他线程是空闲的</runnable></p>
<p>maximumPoolSize:最大线程数，可允许创建的线程数，corePoolSize和maximumPoolSize设置的边界自动调整池大小：<br>corePoolSize &lt;运行的线程数&lt; maximumPoolSize:仅当队列满时才创建新线程<br>corePoolSize=运行的线程数= maximumPoolSize：创建固定大小的线程池</p>
<p>keepAliveTime:如果线程数多于corePoolSize,则这些多余的线程的空闲时间超过keepAliveTime时将被终止</p>
<p>unit:keepAliveTime参数的时间单位</p>
<p>workQueue:保存任务的阻塞队列，与线程池的大小有关：<br>当运行的线程数少于corePoolSize时，在有新任务时直接创建新线程来执行任务而无需再进队列<br>当运行的线程数等于或多于corePoolSize，在有新任务添加时则选加入队列，不直接创建线程<br>当队列满时，在有新任务时就创建新线程</p>
<p>threadFactory:使用ThreadFactory创建新线程，默认使用defaultThreadFactory创建线程</p>
<p>handle:定义处理被拒绝任务的策略，默认使用ThreadPoolExecutor.AbortPolicy,任务被拒绝时将抛出RejectExecutorException<br>3.Executors：提供了一系列静态工厂方法用于创建各种线程池<br>newFixedThreadPool:创建可重用且固定线程数的线程池，如果线程池中的所有线程都处于活动状态，此时再提交任务就在队列中等待，直到有可用线程；如果线程池中的某个线程由于异常而结束时，线程池就会再补充一条新线程。<br>方法签名：<br>public static ExecutorService newFixedThreadPool(int nThreads) {<br>    return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,<br>    //使用一个基于FIFO排序的阻塞队列，在所有corePoolSize线程都忙时新任务将在队列中等待<br>    new LinkedBlockingQueue<runnable>());<br>}<br>newSingleThreadExecutor:创建一个单线程的Executor，如果该线程因为异常而结束就新建一条线程来继续执行后续的任务<br>方法签名：<br>public static ExecutorService newSingleThreadExecutor() {<br>    return new FinalizableDelegatedExecutorService<br>//corePoolSize和maximumPoolSize都等于，表示固定线程池大小为1<br>    (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,<br>    new LinkedBlockingQueue<runnable>()));<br>}<br>newScheduledThreadPool:创建一个可延迟执行或定期执行的线程池<br>方法签名：</runnable></runnable></p>
<p>使用newScheduledThreadPool来模拟心跳机制<br>public class HeartBeat {<br>public static void main(String[] args) {<br>ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);<br>Runnable task = new Runnable() {<br>public void run() {<br>System.out.println(“HeartBeat…………………….”);<br>}<br>};<br>executor.scheduleAtFixedRate(task,5,3, TimeUnit.SECONDS);   //5秒后第一次执行，之后每隔3秒执行一次<br>}<br>}<br>newCachedThreadPool:创建可缓存的线程池，如果线程池中的线程在60秒未被使用就将被移除，在执行新的任务时，当线程池中有之前创建的可用线程就重      用可用线程，否则就新建一条线程<br>方法签名：<br>public static ExecutorService newCachedThreadPool() {<br>    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,<br>    //使用同步队列，将任务直接提交给线程<br>    new SynchronousQueue<runnable>());<br>}<br>通过使用Executor可以很轻易的实现各种调优  管理  监视  记录日志和错误报告等待。<br>4.Executor的生命周期<br>ExecutorService提供了管理Eecutor生命周期的方法，ExecutorService的生命周期包括了：运行  关闭和终止三种状态。</runnable></p>
<p>ExecutorService在初始化创建时处于运行状态。<br>shutdown方法等待提交的任务执行完成并不再接受新任务，在完成全部提交的任务后关闭<br>shutdownNow方法将强制终止所有运行中的任务并不再允许提交新任务<br>可以将一个Runnable或Callable提交给ExecutorService的submit方法执行，最终返回一上Futire用来获得任务的执行结果或取消任务<br>public class CallableAndFuture {<br>public static void main(String[] args) throws ExecutionException, InterruptedException {<br>ExecutorService executor = Executors.newSingleThreadExecutor();<br>Future<string> future = executor.submit(new Callable<string>() {   //接受一上callable实例<br>public String call() throws Exception {<br>return “MOBIN”;<br>}<br>});<br>System.out.println(“任务的执行结果：”+future.get());<br>}<br>}<br>ExecutorCompletionService:实现了CompletionService，将执行完成的任务放到阻塞队列中，通过take或poll方法来获得执行结果<br>public class CompletionServiceTest {<br>public static void main(String[] args) throws InterruptedException, ExecutionException {<br>ExecutorService executor = Executors.newFixedThreadPool(10);        //创建含10.条线程的线程池<br>CompletionService completionService = new ExecutorCompletionService(executor);<br>for (int i =1; i &lt;=10; i ++) {<br>final  int result = i;<br>completionService.submit(new Callable() {<br>public Object call() throws Exception {<br>Thread.sleep(new Random().nextInt(5000));   //让当前线程随机休眠一段时间<br>return result;<br>}<br>});<br>}<br>System.out.println(completionService.take().get());   //获取执行结果<br>}<br>}<br>通过Executor来设计应用程序可以简化开发过程，提高开发效率，并有助于实现并发，在开发中如果需要创建线程可优先考虑使用Executor</string></string></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/java并发编程--Executor框架/" data-id="cjh1laqwe0002a5bt2wyvdjvk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/hello-world/" class="article-date">
  <time datetime="2018-04-10T03:14:59.726Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/hello-world/">杨佳妮</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LOVE U</p>
<p>## </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My Blog Start</span><br></pre></td></tr></table></figure>
<p>初次博客尝试，处女座给你看了。怎么奖励我啊<br>嘿嘿 爱你 宝贝儿 mua</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/hello-world/" data-id="cjh1laqwf0003a5btfhg6ecj4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-boot前后端交互的工具类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/spring-boot前后端交互的工具类/" class="article-date">
  <time datetime="2018-04-10T03:14:59.726Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/spring-boot前后端交互的工具类/">spring-boot前后端交互的工具类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>元注解是注解的注解，包括@Retention @Target @Document @Inherited四种</p>
<p>##<br>package com.baidu.p2p.core.j2ee.action;</p>
<p>import java.util.ArrayList;<br>import java.util.HashMap;<br>import java.util.Map;</p>
<p>import org.apache.commons.lang3.ArrayUtils;<br>import org.apache.commons.lang3.Validate;<br>import org.apache.ibatis.reflection.MetaObject;<br>import org.apache.ibatis.reflection.SystemMetaObject;</p>
<p>import com.baidu.p2p.core.fastjson.JSONStringBuilder;<br>import com.baidu.p2p.core.j2ee.exception.BaseRuntimeException;<br>import com.baidu.p2p.core.j2ee.exception.NoPermissionException;<br>import com.baidu.p2p.core.utils.Exceptions;<br>import com.baidu.p2p.core.utils.StringUtils;<br>import com.baidu.p2p.core.utils.UtilType;<br>import com.google.common.collect.Maps;</p>
<p>public class JsonResult<t> {<br>public static void main(String[] args) {<br>JsonResult&lt;?&gt; o = new JsonResult&lt;&gt;();<br>System.out.println(o.data(“xx”, 12).toJSONString());</t></p>
<p>HashMap&lt;String, Object&gt; data = Maps.newHashMap();<br>data.put(“list”, new ArrayList&lt;&gt;());<br>data.put(“total”, 100);</p>
<p>System.out.println(JsonResult.okJsonResultWithData(data).toJSONString());</p>
<p>System.out.println(JsonResult.failJsonResult(“错误！”).toJSONString());</p>
<p>System.out.println(JsonResult.needLoginJsonResult().toJSONString());</p>
<p>}</p>
<p>public static final String ERROR = “error”;<br>public static final String OK = “ok”;<br>public static final String NEED_LOGIN = “needLogin”;<br>public static final String PERMISSION_DENY = “permissionDeny”;</p>
<p>public static final String SESSION_TIMEOUT = “sessionTimeout”;<br>public static final String DATABAS_EEXCEPTION = “databaseException”;</p>
<p>public static final String JSON_TYPE = “json”;<br>public static final String TEXT_TYPE = “text”;<br>public static final String FORWARD_TYPE = “forward”;</p>
<p>private String status;<br>private String message;<br>private String type;<br>private Integer total;<br>private Boolean onlyData;<br>private String dateFmt;<br>private String debugInfo;</p>
<p>private T data;</p>
<p>public String getDebugInfo() {<br>return debugInfo;<br>}</p>
<p>public void setDebugInfo(String debugInfo) {<br>this.debugInfo = debugInfo;<br>}</p>
<p>public boolean jsonType() {<br>return (StringUtils.equalsIgnoreCase(JSON_TYPE, this.getType()));<br>}</p>
<p>public boolean textType() {<br>return (StringUtils.equalsIgnoreCase(TEXT_TYPE, this.getType()));<br>}</p>
<p>public boolean forwardType() {<br>return (StringUtils.equalsIgnoreCase(FORWARD_TYPE, this.getType()));<br>}</p>
<p>public String getDateFmt() {<br>return dateFmt;<br>}</p>
<p>public void setDateFmt(String dateFmt) {<br>this.dateFmt = dateFmt;<br>}</p>
<p>public static <t> JsonResult<t> okJsonResultWithData(T data) {<br>JsonResult<t> jsonResult = new JsonResult&lt;&gt;();<br>jsonResult.setData(data);<br>return jsonResult;<br>}</t></t></t></p>
<p>public static JsonResult&lt;?&gt; okJsonResult() {<br>return okJsonResultWithMsg(“”);<br>}</p>
<p>public static JsonResult&lt;?&gt; okJsonResultWithMsg(String message) {<br>JsonResult&lt;?&gt; jsonResult = new JsonResult&lt;&gt;();<br>jsonResult.setMessage(message);<br>return jsonResult;<br>}</p>
<p>public static JsonResult<string> okJsonResultWithContent(String dataType, String content) {<br>JsonResult<string> jsonResult = new JsonResult&lt;&gt;();<br>jsonResult.setType(dataType);<br>jsonResult.setData(content);<br>return jsonResult;<br>}</string></string></p>
<p>public static JsonResult<string> okJsonResultWithForward(String forwardUrl) {<br>JsonResult<string> jsonResult = new JsonResult<string>();<br>jsonResult.setForwardUrl(forwardUrl);<br>return jsonResult;<br>}</string></string></string></p>
<p>public static JsonResult&lt;?&gt; failJsonResult(String message) {<br>JsonResult&lt;?&gt; jsonResult = new JsonResult&lt;&gt;();<br>jsonResult.setStatus(ERROR);<br>jsonResult.setMessage(message);<br>return jsonResult;<br>}<br>public static JsonResult&lt;?&gt; failJsonResult(Throwable wrapped) {<br>JsonResult&lt;?&gt; jsonResult = null;<br>if (wrapped instanceof IllegalArgumentException) {<br>jsonResult = failJsonResult(Exceptions.getMsg(wrapped));<br>} else if (!(wrapped instanceof BaseRuntimeException)) {<br>jsonResult = failJsonResult(“出错了，请检查！”);<br>} else {<br>BaseRuntimeException bre = (BaseRuntimeException) wrapped;<br>if (bre.getMessage() == null &amp;&amp; bre.getErrorCode() == null) {<br>jsonResult = failJsonResult(“出错了，请检查！”);<br>} else {<br>jsonResult = failJsonResult(Exceptions.getMsg(wrapped));<br>}<br>}<br>jsonResult.setDebugInfo(Exceptions.getStackTraceAsString(wrapped));<br>return jsonResult;<br>}<br>public static JsonResult&lt;?&gt; failJsonResult(String status, String message) {<br>JsonResult&lt;?&gt; jsonResult = new JsonResult&lt;&gt;();<br>jsonResult.setStatus(status);<br>jsonResult.setMessage(message);<br>return jsonResult;<br>}</p>
<p>public static <t> JsonResult<t> failJsonResultWithData(T data) {<br>JsonResult<t> jsonResult = new JsonResult<t>();<br>jsonResult.setStatus(ERROR);<br>jsonResult.setData(data);<br>return jsonResult;<br>}</t></t></t></t></p>
<p>public static JsonResult&lt;?&gt; needLoginJsonResult() {<br>JsonResult&lt;?&gt; jsonResult = new JsonResult&lt;&gt;();<br>jsonResult.setStatus(NEED_LOGIN);<br>jsonResult.setMessage(“need login!”);<br>jsonResult.setForwardUrl(“/logout”);<br>return jsonResult;<br>}</p>
<p>public static JsonResult&lt;?&gt; permissionDenyJsonResult() {<br>return permissionDenyJsonResult(PERMISSION_DENY);<br>}</p>
<p>public static JsonResult&lt;?&gt; permissionDenyJsonResult(String message) {<br>JsonResult&lt;?&gt; jsonResult = new JsonResult&lt;&gt;();<br>jsonResult.setStatus(PERMISSION_DENY);<br>jsonResult.setMessage(message);<br>return jsonResult;<br>}</p>
<p>public static JsonResult&lt;?&gt; permissionDenyJsonResult(NoPermissionException ex) {<br>JsonResult&lt;?&gt; jsonResult = new JsonResult&lt;&gt;();<br>jsonResult.setStatus(PERMISSION_DENY);<br>jsonResult.setMessage(StringUtils.isEmpty(ex.getMessage()) ? PERMISSION_DENY : ex.getMessage());<br>return jsonResult;<br>}</p>
<p>public JsonResult() {<br>this.setStatus(OK);<br>}</p>
<p>public T getData() {<br>return data;<br>}</p>
<p>public void setData(T data) {<br>this.data = data;<br>}</p>
<p>public void setData(T data, boolean b) {<br>this.onlyData(b).setData(data);<br>}</p>
<p>@SuppressWarnings(“unchecked”)<br>public JsonResult<t> data(Map&lt;String, Object&gt; map) {<br>if (this.data == null) {<br>this.data = (T) Maps.&lt;String, Object&gt;newLinkedHashMap();<br>}<br>UtilType.copyProperties(data, map);<br>return this;<br>}</t></p>
<p>@SuppressWarnings(“unchecked”)<br>public JsonResult<t> data(String key, Object value) {<br>if (this.data == null) {<br>this.data = (T) Maps.&lt;String, Object&gt;newLinkedHashMap();<br>}<br>MetaObject metaObject = SystemMetaObject.forObject(data);<br>metaObject.setValue(key, value);<br>return this;<br>}</t></p>
<p>public Boolean isOnlyData() {<br>return onlyData;<br>}</p>
<p>public JsonResult<t> onlyData(Boolean onlyData) {<br>this.onlyData = onlyData;<br>return this;<br>}</t></p>
<p>@SuppressWarnings(“unchecked”)<br>public void setForwardUrl(String forwardUrl) {<br>this.setType(FORWARD_TYPE);<br>this.setData(((T) forwardUrl));<br>}</p>
<p>public String getType() {<br>return type;<br>}</p>
<p>public void setType(String type) {<br>this.type = type;<br>}</p>
<p>public String getStatus() {<br>return status;<br>}</p>
<p>public void setStatus(String statusCode) {<br>this.status = statusCode;<br>}</p>
<p>public String getMessage() {<br>return message;<br>}</p>
<p>public void setMessage(String message) {<br>this.message = message;<br>}</p>
<p>public Integer getTotal() {<br>return total;<br>}</p>
<p>public void setTotal(Integer total) {<br>this.total = total;<br>}</p>
<p>public String toJSONString() {<br>Validate.notBlank(this.getStatus(), “必须提供StatusCode”);<br>JSONStringBuilder builder = null;<br>if (onlyData != null &amp;&amp; this.isOnlyData()) {<br>builder = new JSONStringBuilder(data);<br>} else {<br>builder = new JSONStringBuilder(this);<br>}<br>String[] excludes = {“dateFmt”};<br>if (StringUtils.isEmpty(this.message)) {<br>excludes = ArrayUtils.add(excludes, “message”);<br>}<br>return builder.dateFmt(dateFmt).exclude(excludes).toString();<br>}</p>
<p>}</p>
<p>使用方法为JsonResult.okJsonResult()等等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/spring-boot前后端交互的工具类/" data-id="cjh1laqwh0004a5btwnzeumld" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java面试整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/java面试整理/" class="article-date">
  <time datetime="2018-04-10T03:14:59.726Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/java面试整理/">Java面试整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##<br>set无序  不可放重复数据会被覆盖 hashset treeset set是链表结构存储的 list是数组结构存储的<br>list有序 可以存入重复数据 arrayList linkedlist  map是数组和链表的结合体<br>hashtable stringbuffer vector线程安全</p>
<p>string为字符串常量<br>stringbuilder和stringbuffer是字符串变量<br>stringbuffer线程安全<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>
<p>左连接结果集包括左边所有数据<br>右链接结果集包括右边所有数据<br>内连接结果集只显示匹配的</p>
<p>拦截器和过滤器的区别<br>本质不同，拦截器是基于java的反射机制。过滤器是基于函数回调<br>拦截器不依赖servlet容器，过滤器依赖<br>拦截器只对action起作用，过滤器几乎所有请求都有作用<br>拦截器可以对action上下文和值栈里的对象进行访问<br>过滤器只在容器初始化时调用一次</p>
<p>forward与redirect<br>转发和重定向<br>forward转发页面和转发到的页面可以共享request里面的数据，<br>服务器直接访问目标地址的url地址栏还是原来的地址浏览器不知道内容的来源<br>redirect重定向不能共享<br>重定向是服务器给浏览器发一个状态码，浏览器去请求地址。显示的是新的url</p>
<p>hashmap几乎等同于hashtable不过hashmap非线程安全并且可以接受null</p>
<p>数据库主键的几种设计方式<br>1，采用guid优势是全球唯一产生方便，维护方便。但性能最低<br>2，采用数据库自动增长的方式，性能好，产生方便，但维护麻烦一般用于不需要维护的特殊表比如日志<br>3，采用int型作为主键，性能好产生方便维护也方便但不具有任何意义<br>4，采用身份证等具有唯一标示作用的，性能一般，产生方便维护一般</p>
<p>alter table tablename add cloume datatype<br>CREATE TABLE table_name (column_name column_type);<br>线程问题<br>线程的生命周期<br>新建-就绪-运行-阻塞-死亡 5种状态<br>new是新建 start就绪 runing运行 blocked阻塞 dead死亡<br>线程在以下5种情况下会进入阻塞状态<br>1》线程调用sleep方法主动放弃处理器资源<br>2》线程调用一个阻塞式IO方法在该方法返回之前<br>3》线程获得了一个同步监视器该监视器正在被其他线程所持有<br>4》线程在等待某个通知notify<br>5》调用了suspend方法将该线程挂起，但该方法容易造成死锁<br>阻塞恢复运行的几种情况<br>1》sleep时限已过<br>2》IO方法返回<br>3》线程获得了监视器<br>4》其他线程发出一个通知<br>5》处于挂起的线程resume恢复<br>线程池的原理<br>就是队列和线程复用机制</p>
<p>定时任务的实现方式<br>1》jdk自带的timer和scheduleExecutorservice<br>2》quartz<br>3》spring3.0以后自带的task<br>实例<br>1，配置一个监听器加载一个监控类<br>2，书写监听器实例化监听类<br>3，书写一个任务类（执行需要定时执行的任务内容）<br>4，监听类timer。schedule（task(任务类)，data（第一次执行任务的时间），PERIOD_DAY（任务的间隔时间））</p>
<p>jvm 堆和栈<br>基本类型的变量和对象的引用变量都是在函数的栈内存中分配的 定义变量分配空间，超过作用域释放空间<br>堆内存用于存放new创建的对象和数组<br>栈是运行时单位，堆是存储单位，一个线程就与一个栈相对应</p>
<p>hibernate与mybatis的区别<br>hibernate是全自动的mybatis半自动<br>hibernate可以通过对象关系模型实现对数据库的操作拥有完整的bean对象和数据库的影射来自动生成sql<br>而mybatis仅有基本的字段影射<br>hibernate具有更好的移植性<br>hibernate拥有完整的日志系统<br>sql直接优化上mybatis比hibernate方便mybatis的sql都在xml hibernate的sql很多都是自动生成的无法直接维护<br>灵活度上不如mybatis</p>
<p>get和post请求的区别<br>get浏览器回退时无害post会再次提出请求<br>get比post更不安全参数会直接暴露在url上<br>get请求可以被缓存post默认的不会有缓存</p>
<p>缓存架构redis和memcached<br>都是内存数据库都是将数据放入内存中提高效率的不过memcache还可以缓存其他如图片视频<br>redis不仅仅支持kv类型的数据还提供了list，set，hash等数据结构的存储<br>redis在物理内存用完时会将很久没用的value交换到磁盘上<br>过期策略redis可以灵活设定memchche在set时就制定了<br>redis支持5种数据类型string，hash，list，set，zset（有序集合）</p>
<p>线程池<br>newCachedTHreadPool<br>可缓存线程池如果线程长度超过需要可灵活回收空闲线程若无则新建<br>用他要注意控制任务的数量 工作空闲默认1分钟则线程终止<br>newFixedThreadPool<br>指定工作线程数量的线程池提交一个任务建一个线程达到最大数任务存到池队列<br>具有提高效率和节省创建线程所耗得开销的有点但没有任务时还会占用资源<br>newSingleThreadExecutor<br>创建单线程话的executor特点单个线程 顺序执行  改线程坏了会新建一个<br>newScheduleThreadPool<br>定长线程池支持定时以及周期性的任务执行</p>
<p>接口的作用<br>实现多继承，实现各种框架，接口规范，维护拓展性</p>
<p>java创建对象的几种方式<br>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>
<p>对象模块加载的顺序<br>（1）类加载按从上到下执行static修饰的静态模块<br>（2）静态模块执行完之后执行main（）方法<br>（3）如果有语句new了自身的对象将从上到下执行构造代码，构造器</p>
<p>基本数据类型<br>其中byte、short、int、long都是表示整数的，只不过他们的取值范围不一样<br>byte的取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1）<br>short的取值范围为-32768~32767，占用2个字节（-2的15次方到2的15次方-1）<br>int的取值范围为（-2147483648~2147483647），占用4个字节（-2的31次方到2的31次方-1）<br>long的取值范围为（-9223372036854774808~9223372036854774807），占用8个字节（-2的63次方到2的63次方-1）</p>
<p>解析xml的四种方式<br>dom解析，sax解析，jdom解析，dom4j解析</p>
<p>zookeeper<br>服务注册中心作为服务提供者和服务消费者的中间协调人<br>提供者将服务注册到服务注册中心然后服务消费者启动时获取服务注册信息并监听服务的变化最后实现的是服务<br>消费者调用服务提供者提供的服务<br>服务提供者提供的服务信息包括（隶属于哪一个系统，服务的ip和端口，服务的请求url，服务的权重等等）<br>zk服务注册中心主要提供所有注册信息的中心存储同时 将服务的更新通知给消费者（主要通过zk的watcher实现）<br>服务消费者主要进行的操作是<br>注册时从服务中西获取服务注册信息，将服务注册信息缓存到本地，监听服务注册信息的变更，并更新本地的服务注册信息，</p>
<p>oracle的分页sql<br>SELECT <em> FROM  (  SELECT A.</em>, ROWNUM RN  FROM (SELECT <em> FROM TABLE_NAME) A  WHERE ROWNUM &lt;= 40  )  WHERE RN &gt;= 21<br>SELECT </em> FROM  (  SELECT A.<em>, ROWNUM RN  FROM (SELECT </em> FROM TABLE_NAME) A  )  WHERE RN BETWEEN 21 AND 40<br>sql的分页sql<br>取前5条数据<br>select <em> from table_name limit 0,5<br>或者<br>select </em> from table_name limit 5<br>查询第11到第15条数据<br>select * from table_name limit 10,5<br>limit关键字的用法：<br>LIMIT [offset,] rows<br>offset指定要返回的第一行的偏移量，rows第二个指定返回行的最大数目。初始行的偏移量是0(不是1)。</p>
<p>spring配置声明式事务<br>配置datasource<br>配置事务管理器<br>事务的传播特性<br>哪些类哪些方法使用事务 spring配置事务由三部分构成分别是datasource，transactionmanager和代理机制三部分</p>
<p>hibernate的缓存机制<br>session的缓存被称为hibernate的第一级缓存<br>sessionfactory的外置缓存被称为hibernate的二级缓存这两个都位于持久层他们存放的都是数据库数据的备份<br>sessionfactory的内置缓存存放元数据和预定义sql内置缓存是只读缓存<br>session缓存的三大作用<br>1减少数据库的访问频率<br>2保证缓存中的对象和数据库同步，位于缓存中的对象称为持久化对象<br>3挡持久化对象之间存在关联时session保证不出现对象图的死锁<br>session加载对象后会对对象的属性复制一份快照在session清理缓存时会做一个比较知道哪些属性变化了<br>session什么时候清理缓存<br>1commit调用时<br>2查询时会清理保证查询的是对象的最新状态<br>3显示的调用session的flush方法<br>当对象使用natice生成器会立刻清理缓存向数据库中插入记录</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/java面试整理/" data-id="cjh1laqwi0005a5bta31x44ep" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/10/git的使用经验/">git的使用经验</a>
          </li>
        
          <li>
            <a href="/2018/04/10/java四大元注解/">JAVA的四大元注解</a>
          </li>
        
          <li>
            <a href="/2018/04/10/java并发编程--Executor框架/">JAVA并发编程--Executor</a>
          </li>
        
          <li>
            <a href="/2018/04/10/hello-world/">杨佳妮</a>
          </li>
        
          <li>
            <a href="/2018/04/10/spring-boot前后端交互的工具类/">spring-boot前后端交互的工具类</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 崔建东<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>