<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>面试整理 | 崔先生的Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="##set无序  不可放重复数据会被覆盖 hashset treeset set是链表结构存储的 list是数组结构存储的list有序 可以存入重复数据 arrayList linkedlist  map是数组和链表的结合体hashtable stringbuffer vector线程安全 string为字符串常量stringbuilder和stringbuffer是字符串变量stringbuff">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理">
<meta property="og:url" content="http://yoursite.com/2018/04/10/java面试整理/index.html">
<meta property="og:site_name" content="崔先生的Blog">
<meta property="og:description" content="##set无序  不可放重复数据会被覆盖 hashset treeset set是链表结构存储的 list是数组结构存储的list有序 可以存入重复数据 arrayList linkedlist  map是数组和链表的结合体hashtable stringbuffer vector线程安全 string为字符串常量stringbuilder和stringbuffer是字符串变量stringbuff">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-04-11T06:56:14.639Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试整理">
<meta name="twitter:description" content="##set无序  不可放重复数据会被覆盖 hashset treeset set是链表结构存储的 list是数组结构存储的list有序 可以存入重复数据 arrayList linkedlist  map是数组和链表的结合体hashtable stringbuffer vector线程安全 string为字符串常量stringbuilder和stringbuffer是字符串变量stringbuff">
  
    <link rel="alternate" href="/atom.xml" title="崔先生的Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">崔先生的Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java面试整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/java面试整理/" class="article-date">
  <time datetime="2018-04-10T03:14:59.726Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面试整理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##<br>set无序  不可放重复数据会被覆盖 hashset treeset set是链表结构存储的 list是数组结构存储的<br>list有序 可以存入重复数据 arrayList linkedlist  map是数组和链表的结合体<br>hashtable stringbuffer vector线程安全</p>
<p>string为字符串常量<br>stringbuilder和stringbuffer是字符串变量<br>stringbuffer线程安全<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>
<p>左连接结果集包括左边所有数据<br>右链接结果集包括右边所有数据<br>内连接结果集只显示匹配的</p>
<p>拦截器和过滤器的区别<br>本质不同，拦截器是基于java的反射机制。过滤器是基于函数回调<br>拦截器不依赖servlet容器，过滤器依赖<br>拦截器只对action起作用，过滤器几乎所有请求都有作用<br>拦截器可以对action上下文和值栈里的对象进行访问<br>过滤器只在容器初始化时调用一次</p>
<p>forward与redirect<br>转发和重定向<br>forward转发页面和转发到的页面可以共享request里面的数据，<br>服务器直接访问目标地址的url地址栏还是原来的地址浏览器不知道内容的来源<br>redirect重定向不能共享<br>重定向是服务器给浏览器发一个状态码，浏览器去请求地址。显示的是新的url</p>
<p>hashmap几乎等同于hashtable不过hashmap非线程安全并且可以接受null</p>
<p>数据库主键的几种设计方式<br>1，采用guid优势是全球唯一产生方便，维护方便。但性能最低<br>2，采用数据库自动增长的方式，性能好，产生方便，但维护麻烦一般用于不需要维护的特殊表比如日志<br>3，采用int型作为主键，性能好产生方便维护也方便但不具有任何意义<br>4，采用身份证等具有唯一标示作用的，性能一般，产生方便维护一般</p>
<p>alter table tablename add cloume datatype<br>CREATE TABLE table_name (column_name column_type);<br>线程问题<br>线程的生命周期<br>新建-就绪-运行-阻塞-死亡 5种状态<br>new是新建 start就绪 runing运行 blocked阻塞 dead死亡<br>线程在以下5种情况下会进入阻塞状态<br>1》线程调用sleep方法主动放弃处理器资源<br>2》线程调用一个阻塞式IO方法在该方法返回之前<br>3》线程获得了一个同步监视器该监视器正在被其他线程所持有<br>4》线程在等待某个通知notify<br>5》调用了suspend方法将该线程挂起，但该方法容易造成死锁<br>阻塞恢复运行的几种情况<br>1》sleep时限已过<br>2》IO方法返回<br>3》线程获得了监视器<br>4》其他线程发出一个通知<br>5》处于挂起的线程resume恢复<br>线程池的原理<br>就是队列和线程复用机制</p>
<p>定时任务的实现方式<br>1》jdk自带的timer和scheduleExecutorservice<br>2》quartz<br>3》spring3.0以后自带的task<br>实例<br>1，配置一个监听器加载一个监控类<br>2，书写监听器实例化监听类<br>3，书写一个任务类（执行需要定时执行的任务内容）<br>4，监听类timer。schedule（task(任务类)，data（第一次执行任务的时间），PERIOD_DAY（任务的间隔时间））</p>
<p>jvm 堆和栈<br>基本类型的变量和对象的引用变量都是在函数的栈内存中分配的 定义变量分配空间，超过作用域释放空间<br>堆内存用于存放new创建的对象和数组<br>栈是运行时单位，堆是存储单位，一个线程就与一个栈相对应</p>
<p>hibernate与mybatis的区别<br>hibernate是全自动的mybatis半自动<br>hibernate可以通过对象关系模型实现对数据库的操作拥有完整的bean对象和数据库的影射来自动生成sql<br>而mybatis仅有基本的字段影射<br>hibernate具有更好的移植性<br>hibernate拥有完整的日志系统<br>sql直接优化上mybatis比hibernate方便mybatis的sql都在xml hibernate的sql很多都是自动生成的无法直接维护<br>灵活度上不如mybatis</p>
<p>get和post请求的区别<br>get浏览器回退时无害post会再次提出请求<br>get比post更不安全参数会直接暴露在url上<br>get请求可以被缓存post默认的不会有缓存</p>
<p>缓存架构redis和memcached<br>都是内存数据库都是将数据放入内存中提高效率的不过memcache还可以缓存其他如图片视频<br>redis不仅仅支持kv类型的数据还提供了list，set，hash等数据结构的存储<br>redis在物理内存用完时会将很久没用的value交换到磁盘上<br>过期策略redis可以灵活设定memchche在set时就制定了<br>redis支持5种数据类型string，hash，list，set，zset（有序集合）</p>
<p>线程池<br>newCachedTHreadPool<br>可缓存线程池如果线程长度超过需要可灵活回收空闲线程若无则新建<br>用他要注意控制任务的数量 工作空闲默认1分钟则线程终止<br>newFixedThreadPool<br>指定工作线程数量的线程池提交一个任务建一个线程达到最大数任务存到池队列<br>具有提高效率和节省创建线程所耗得开销的有点但没有任务时还会占用资源<br>newSingleThreadExecutor<br>创建单线程话的executor特点单个线程 顺序执行  改线程坏了会新建一个<br>newScheduleThreadPool<br>定长线程池支持定时以及周期性的任务执行</p>
<p>接口的作用<br>实现多继承，实现各种框架，接口规范，维护拓展性</p>
<p>java创建对象的几种方式<br>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>
<p>对象模块加载的顺序<br>（1）类加载按从上到下执行static修饰的静态模块<br>（2）静态模块执行完之后执行main（）方法<br>（3）如果有语句new了自身的对象将从上到下执行构造代码，构造器</p>
<p>基本数据类型<br>其中byte、short、int、long都是表示整数的，只不过他们的取值范围不一样<br>byte的取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1）<br>short的取值范围为-32768~32767，占用2个字节（-2的15次方到2的15次方-1）<br>int的取值范围为（-2147483648~2147483647），占用4个字节（-2的31次方到2的31次方-1）<br>long的取值范围为（-9223372036854774808~9223372036854774807），占用8个字节（-2的63次方到2的63次方-1）</p>
<p>解析xml的四种方式<br>dom解析，sax解析，jdom解析，dom4j解析</p>
<p>zookeeper<br>服务注册中心作为服务提供者和服务消费者的中间协调人<br>提供者将服务注册到服务注册中心然后服务消费者启动时获取服务注册信息并监听服务的变化最后实现的是服务<br>消费者调用服务提供者提供的服务<br>服务提供者提供的服务信息包括（隶属于哪一个系统，服务的ip和端口，服务的请求url，服务的权重等等）<br>zk服务注册中心主要提供所有注册信息的中心存储同时 将服务的更新通知给消费者（主要通过zk的watcher实现）<br>服务消费者主要进行的操作是<br>注册时从服务中西获取服务注册信息，将服务注册信息缓存到本地，监听服务注册信息的变更，并更新本地的服务注册信息，</p>
<p>oracle的分页sql<br>SELECT <em> FROM  (  SELECT A.</em>, ROWNUM RN  FROM (SELECT <em> FROM TABLE_NAME) A  WHERE ROWNUM &lt;= 40  )  WHERE RN &gt;= 21<br>SELECT </em> FROM  (  SELECT A.<em>, ROWNUM RN  FROM (SELECT </em> FROM TABLE_NAME) A  )  WHERE RN BETWEEN 21 AND 40<br>sql的分页sql<br>取前5条数据<br>select <em> from table_name limit 0,5<br>或者<br>select </em> from table_name limit 5<br>查询第11到第15条数据<br>select * from table_name limit 10,5<br>limit关键字的用法：<br>LIMIT [offset,] rows<br>offset指定要返回的第一行的偏移量，rows第二个指定返回行的最大数目。初始行的偏移量是0(不是1)。</p>
<p>spring配置声明式事务<br>配置datasource<br>配置事务管理器<br>事务的传播特性<br>哪些类哪些方法使用事务 spring配置事务由三部分构成分别是datasource，transactionmanager和代理机制三部分</p>
<p>hibernate的缓存机制<br>session的缓存被称为hibernate的第一级缓存<br>sessionfactory的外置缓存被称为hibernate的二级缓存这两个都位于持久层他们存放的都是数据库数据的备份<br>sessionfactory的内置缓存存放元数据和预定义sql内置缓存是只读缓存<br>session缓存的三大作用<br>1减少数据库的访问频率<br>2保证缓存中的对象和数据库同步，位于缓存中的对象称为持久化对象<br>3挡持久化对象之间存在关联时session保证不出现对象图的死锁<br>session加载对象后会对对象的属性复制一份快照在session清理缓存时会做一个比较知道哪些属性变化了<br>session什么时候清理缓存<br>1commit调用时<br>2查询时会清理保证查询的是对象的最新状态<br>3显示的调用session的flush方法<br>当对象使用natice生成器会立刻清理缓存向数据库中插入记录</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/java面试整理/" data-id="cjg7nb9f1000288btrs1i416h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/04/10/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          杨佳妮
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/10/git的使用经验/">git的使用经验</a>
          </li>
        
          <li>
            <a href="/2018/04/10/hello-world/">杨佳妮</a>
          </li>
        
          <li>
            <a href="/2018/04/10/java面试整理/">面试整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 崔建东<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>